import cv2
import numpy as np

global col1, col2, col3, col4
col1 = ()
col2 = ()
col3 = ()
col4 = ()


global colors_left
colors_left = []

# colors = [(255, 105, 97), (255, 180, 128), (248, 243, 141), (66, 214, 164), (8, 202, 209), (89, 173, 246), (157, 148, 255), (199, 128, 232)]
colors = [(87, 118, 158), (214, 100, 190), (223, 153, 240), (177, 145, 255)]

def color_generator():
    global colors_left
    if colors_left == []:
        colors_left = colors.copy()  # Make a copy of the original list
    num_left = len(colors_left)
    colour_select = colors_left.pop(np.random.choice(num_left))  # Remove and return a random color
    return colour_select

#Open a live camera feed
cap = cv2.VideoCapture(1)
while True:
    #Get the frame
    ret, frame = cap.read()

    # Get the dimensions of the frame
    height, width, channels = frame.shape

    #-----Create canvas of same dimension as image and add image to the exact place it way in image using the coordinates
    # Define the dimensions of the white canvas
    canvas_height, canvas_width = height, width

    # Create a white canvas
    final_canvas = np.ones((canvas_height, canvas_width, 3), dtype=np.uint8) * 255  # 3 for RGB channels

    # Calculate position to place the image in the center
    start_x = (canvas_width - width) // 1
    start_y = (canvas_height - height) // 1

    # Paste the color image onto the middle of the white canvas
    final_canvas[start_y:start_y+height, start_x:start_x+width] = frame
    #-----

    # Convert the image to grayscale
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)


    # Apply a face detection algorithm to get the face region
    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5)

    # # Get the coordinates of the face and neck
    if len(faces) > 0:

        for f in faces:
            x, y, w, h = f
            face_neck = frame[y:y+h, x:x+w]

            # Convert the face + neck to black and white
            bw_face_neck = cv2.cvtColor(face_neck, cv2.COLOR_BGR2GRAY)

            height, width = bw_face_neck.shape

            # Create a white canvas for the lines
            white_canvas = np.ones((height, width, 3), dtype=np.uint8) * 255

            #Add lines for little darker shades of gray
            if col1 == (): #If col1 is not empty
                col1 = color_generator()
            for i in range(0, width, 8):
                for j in range(0, height, 8):
                    pixel_col = bw_face_neck[j, i]
                    if ((pixel_col < 204) & (pixel_col >= 153)):
                        # Draw the line
                        cv2.line(white_canvas, (i, j), (i + 4, j + 4), col1, 1)

            #Add lines for more darker shades of gray
            if col2 == (): #If col2 is not empty
                col2 = color_generator()
            for i in range(0, width, 6):
                for j in range(0, height, 6):
                    pixel_col = bw_face_neck[j, i]
                    if ((pixel_col < 153) & (pixel_col >= 102)):
                        # Draw the line
                        cv2.line(white_canvas, (i, j), (i + 3, j + 3), col2, 1)

            #GSame as above but for even more darker shades of gray
            if col3 == (): #If col3 is not empty
                col3 = color_generator()
            for i in range(0, width, 4):
                for j in range(0, height, 4):
                    pixel_col = bw_face_neck[j, i]
                    if ((pixel_col < 102) & (pixel_col >= 51)):
                        # Draw the line
                        cv2.line(white_canvas, (i, j), (i + 2, j + 2), col3, 1)

            #Add lines for darkest shades of gray
            if col4 == (): #If col4 is not empty
                col4 = color_generator()
            for i in range(0, width, 2):
                for j in range(0, height, 2):
                    pixel_col = bw_face_neck[j, i]
                    if ((pixel_col < 51) & (pixel_col >= 0)):
                        # Draw the line
                        cv2.line(white_canvas, (i, j), (i + 1, j + 1), col4, 1)

            # Paste the smaller image onto the middle of the larger canvas
            final_canvas[y:y+h, x:x+w] = white_canvas
        
        # Show the final image
        cv2.imshow('frame', final_canvas)
        
    else:
        cv2.imshow('frame', frame)

        #Change all the cols to empty
        col1 = ()
        col2 = ()
        col3 = ()
        col4 = ()
        colors_left = []


    # Check for key events
    key = cv2.waitKey(1)
    if key == ord('q') or key == 27:  # 'q' or ESC key
        break
cap.release()
cv2.destroyAllWindows()